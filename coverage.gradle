apply plugin: 'jacoco'

jacoco {
    toolVersion = "0.8.7"
}
ext.excludes = [
        '**/databinding/*Binding.*',
        '**/R.class',
        '**/R$*.class',
        '**/BuildConfig.*',
        '**/Manifest*.*',
        '**/*Test*.*',
        'android/**/*.*',
        // butterKnife
        '**/*$ViewInjector*.*',
        '**/*$ViewBinder*.*',
        '**/Lambda$*.class',
        '**/Lambda.class',
        '**/*Lambda.class',
        '**/*Lambda*.class',
        '**/*_MembersInjector.class',
        '**/Dagger*Component*.*',
        '**/*Module_*Factory.class',
        '**/di/module/*',
        '**/*_Factory*.*',
        '**/*Module*.*',
        '**/*Dagger*.*',
        '**/*Hilt*.*',
        // kotlin
        '**/*MapperImpl*.*',
        '**/*$ViewInjector*.*',
        '**/*$ViewBinder*.*',
        '**/BuildConfig.*',
        '**/*Component*.*',
        '**/*BR*.*',
        '**/Manifest*.*',
        '**/*$Lambda$*.*',
        '**/*Companion*.*',
        '**/*Module*.*',
        '**/*Dagger*.*',
        '**/*Hilt*.*',
        '**/*MembersInjector*.*',
        '**/*_MembersInjector.class',
        '**/*_Factory*.*',
        '**/*_Provide*Factory*.*',
        '**/*Extensions*.*'
]
project.afterEvaluate {
    plugins.withId('com.android.application') {
        android.applicationVariants.all { variant ->
            createVariantCoverage(variant)
        }
    }
    plugins.withId('com.android.library') {
        android.libraryVariants.all { variant ->
            createVariantCoverage(variant)
        }
    }
    plugins.withId('java-library') {
        project.tasks.withType(JacocoReport).forEach { task ->
            createJavaLibraryCoverage(task)
        }
    }
}

def setupWithAggregateCoverage(variantName, JacocoReport projectTask) {
    def aggregateTaskName = "aggregate${variantName.capitalize()}TestCoverage"
    def aggregateTask = rootProject.tasks.findByName(aggregateTaskName)
    if (aggregateTask == null) {
        aggregateTask = createAggregateCoverage(variantName)
    }

    aggregateTask.getClassDirectories().setFrom(aggregateTask.getClassDirectories() + projectTask.getClassDirectories())
    aggregateTask.getSourceDirectories().setFrom(aggregateTask.getSourceDirectories() + projectTask.getSourceDirectories())
    aggregateTask.getExecutionData().setFrom(aggregateTask.getExecutionData() + projectTask.getExecutionData())
    aggregateTask.dependsOn(projectTask.getDependsOn())
}

def createAggregateCoverage(variantName) {
    JacocoReport aggregateTask = rootProject.tasks.create(name: "aggregate${variantName.capitalize()}TestCoverage", type: JacocoReport, group: 'reporting') {
        reports {
            html.enabled = true
            xml.enabled = true
        }
        doLast {
            def m = new File("${rootProject.buildDir}/reports/jacoco/aggregate${variantName.capitalize()}TestCoverage/html/index.html")
                    .text =~ /Total[^%]*>(\d?\d?\d?%)/
            if (m) {
                println "Test coverage: ${m[0][1]}"
            }
        }
    }

    rootProject.tasks.create(name: "aggregate${variantName.capitalize()}TestCoverageVerification", type: JacocoCoverageVerification, dependsOn: aggregateTask) {
        group = "Reporting"
        description = "Verifies Jacoco coverage for the $variantName build."
        violationRules {
            rule {
                limit {
                    minimum = 0
                }
            }
            rule {
                element = 'BUNDLE'
                limit {
                    counter = 'LINE'
                    value = 'COVEREDRATIO'
                    minimum = 0.30
                }
            }
        }
        getClassDirectories().setFrom(aggregateTask.getClassDirectories())
        getSourceDirectories().setFrom(aggregateTask.getSourceDirectories())
        getExecutionData().setFrom(aggregateTask.getExecutionData())
    }

    // Add JavaLibrary report data
    if (variantName != 'javaLibrary') {
        def aggregateJavaTask = rootProject.tasks.findByName('aggregateJavaLibraryTestCoverage')
        if (aggregateJavaTask != null) {
            setupWithAggregateCoverage(variantName, aggregateJavaTask)
        } else {
            rootProject.tasks.whenTaskAdded { addedTask ->
                if (addedTask.name == 'aggregateJavaLibraryTestCoverage') {
                    setupWithAggregateCoverage(variantName, addedTask)
                }
            }
        }
    }

    return aggregateTask
}

def createVariantCoverage(variant) {
    def variantName = variant.name
    def javaClasses = fileTree(dir: variant.javaCompileProvider.get().destinationDir, excludes: project.excludes)
    def kotlinClasses = fileTree(dir: "${project.buildDir}/tmp/kotlin-classes/${variantName}", excludes: project.excludes)
    def moduleClassDirectories = files([javaClasses, kotlinClasses])
    def moduleSourceDirectories = project.files(variant.sourceSets.java.srcDirs.collect { it.path }.flatten())
    def moduleExecutionData = files([
            fileTree(dir: "${project.buildDir}/outputs/unit_test_code_coverage/${variantName}UnitTest/", includes: ["**/*.exec"]),
            fileTree(dir: "${project.buildDir}/outputs/code_coverage/${variantName}AndroidTest/connected/", includes: ["**/*.ec"])
    ])
    def testTaskName = "test${variantName.capitalize()}UnitTest"
    def androidTestTaskName = "create${variantName.capitalize()}CoverageReport"

    // Add unit test coverage tasks for module
    JacocoReport reportTask = tasks.create(name: "${testTaskName}Coverage", type: JacocoReport) {
        group = "Reporting"
        description = "Generate Jacoco coverage reports for the ${variantName.capitalize()} build."

        reports {
            html.enabled = true
            xml.enabled = true
        }

        getClassDirectories().setFrom(moduleClassDirectories)
        getSourceDirectories().setFrom(moduleSourceDirectories)
        getExecutionData().setFrom(moduleExecutionData)

        doLast {
            def m = new File("${project.buildDir}/reports/jacoco/${testTaskName}Coverage/html/index.html")
                    .text =~ /Total[^%]*>(\d?\d?\d?%)/
            if (m) {
                println "Test coverage: ${m[0][1]}"
            }
        }
    }

    def testTask = project.tasks.findByName(testTaskName)
    def androidCoverageTask = project.tasks.findByName(androidTestTaskName)
    if (testTask != null) {
        reportTask.dependsOn(testTask)
    }

    if (androidCoverageTask != null) {
        reportTask.dependsOn(androidCoverageTask)
    }

    // Add unit test coverage verification tasks
    tasks.create(name: "${testTaskName}CoverageVerification", type: JacocoCoverageVerification, dependsOn: reportTask) {
        group = "Reporting"
        description = "Verifies Jacoco coverage for the ${variantName.capitalize()} build."
        violationRules {
            rule {
                limit {
                    minimum = 0
                }
            }
            rule {
                element = 'BUNDLE'
                limit {
                    counter = 'LINE'
                    value = 'COVEREDRATIO'
                    minimum = 0.30
                }
            }
        }
        getClassDirectories().setFrom(reportTask.classDirectories)
        getSourceDirectories().setFrom(reportTask.sourceDirectories)
        getExecutionData().setFrom(reportTask.executionData)
    }
    setupWithAggregateCoverage(variant.name, reportTask)
}

def createJavaLibraryCoverage(JacocoReport reportTask) {
    reportTask.reports {
        html.enabled = true
        xml.enabled = true
    }
    reportTask.dependsOn(project.tasks.findByName('test'))
    setupWithAggregateCoverage("javaLibrary", reportTask)
}