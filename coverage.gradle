apply plugin: 'jacoco'

jacoco {
    toolVersion = "0.8.8"
}
ext.excludes = [
        '**/databinding/*Binding.*',
        '**/R.class',
        '**/R$*.class',
        '**/BuildConfig.*',
        '**/Manifest*.*',
        '**/*Test*.*',
        'android/**/*.*',
        '**/*_Impl*',
        '**/AndroidBiometricsManager*',
        // butterKnife
        '**/*$ViewInjector*.*',
        '**/*$ViewBinder*.*',
        '**/Lambda$*.class',
        '**/Lambda.class',
        '**/*Lambda.class',
        '**/*Lambda*.class',
        '**/*_MembersInjector.class',
        '**/Dagger*Component*.*',
        '**/*Module_*Factory.class',
        '**/di/module/*',
        '**/*_Factory*.*',
        '**/*Module*.*',
        '**/*Dagger*.*',
        '**/*Hilt*.*',
        // kotlin
        '**/*MapperImpl*.*',
        '**/*$ViewInjector*.*',
        '**/*$ViewBinder*.*',
        '**/BuildConfig.*',
        '**/*Component*.*',
        '**/*BR*.*',
        '**/Manifest*.*',
        '**/*$Lambda$*.*',
        '**/*Companion*.*',
        '**/*Module*.*',
        '**/*Dagger*.*',
        '**/*Hilt*.*',
        '**/*MembersInjector*.*',
        '**/*_MembersInjector.class',
        '**/*_Factory*.*',
        '**/*_Provide*Factory*.*',
        '**/*Extensions*.*',
        '**/*MPOApplication*.*',
]

ext.useLogging = false
def dynamicFeaturesEnabled = (project.findProperty("useDynamicFeatures") ?: "true").toBoolean()

subprojects.each {subproject ->
    subproject.afterEvaluate {
        subproject.plugins.withId('com.android.application') {
            subproject.apply plugin: 'jacoco'
            subproject.jacoco.toolVersion = jacoco.toolVersion
            subproject.android.jacoco.version = jacoco.toolVersion
            subproject.android.applicationVariants.all { variant ->
                createVariantCoverage(subproject, variant)
            }
        }
        subproject.plugins.withId('com.android.library') {
            // Fix for trying to include both navigation-graph and navigation-graph-dynamic
            def skipModule = ((subproject.name == "navigation_graph" && dynamicFeaturesEnabled) ||
                    (subproject.name == "navigation_graph_dynamic" && !dynamicFeaturesEnabled))
            if (!skipModule) {
                subproject.apply plugin: 'jacoco'
                subproject.jacoco.toolVersion = jacoco.toolVersion
                subproject.android.jacoco.version = jacoco.toolVersion
                subproject.android.libraryVariants.all { variant ->
                    createVariantCoverage(subproject, variant)
                }
            }
        }
        subproject.plugins.withId('java-library') {
            subproject.apply plugin: 'jacoco'
            subproject.jacoco.toolVersion = jacoco.toolVersion
            subproject.tasks.withType(JacocoReport).forEach { task ->
                createJavaLibraryCoverage(subproject, task)
            }
        }
    }
}

def setupWithAggregateCoverage(variantName, JacocoReport projectTask) {
    def aggregateTaskName = "aggregate${variantName.capitalize()}TestCoverage"
    def aggregateTask = rootProject.tasks.findByName(aggregateTaskName)
    if (aggregateTask == null) {
        aggregateTask = createAggregateCoverage(variantName)
    }

    aggregateTask.getClassDirectories().setFrom(aggregateTask.getClassDirectories() + projectTask.getClassDirectories())
    aggregateTask.getSourceDirectories().setFrom(aggregateTask.getSourceDirectories() + projectTask.getSourceDirectories())
    aggregateTask.getExecutionData().setFrom(aggregateTask.getExecutionData() + projectTask.getExecutionData())
    aggregateTask.dependsOn(projectTask.getDependsOn())
}

def createAggregateCoverage(variantName) {
    JacocoReport aggregateTask = rootProject.tasks.create(name: "aggregate${variantName.capitalize()}TestCoverage", type: JacocoReport, group: 'reporting') {
        reports {
            xml.required = true
            csv.required = false
        }
        doLast {
            if (project.useLogging) {
                println("aggregate${variantName.capitalize()}TestCoverageVerification")
                println("---------------------------------------------------------------------------")
                println("getClassDirectories:")
                getClassDirectories().forEach { file ->
                    println(file.absolutePath)
                }
                println("---------------------------------------------------------------------------")
                println("getSourceDirectories:")
                getSourceDirectories().forEach { file ->
                    println(file.absolutePath)
                }
                println("---------------------------------------------------------------------------")
                println("getExecutionData:")
                getExecutionData().forEach { file ->
                    println(file.absolutePath)
                }
                println("")
                println("")
            }

            def m = new File("${rootProject.buildDir}/reports/jacoco/aggregate${variantName.capitalize()}TestCoverage/html/index.html")
                    .text =~ /Total[^%]*>(\d?\d?\d?%)/
            if (m) {
                println "Test coverage: ${m[0][1]}"
            }
        }
    }

    rootProject.tasks.create(name: "aggregate${variantName.capitalize()}TestCoverageVerification", type: JacocoCoverageVerification, dependsOn: aggregateTask) {
        group = "Reporting"
        description = "Verifies Jacoco coverage for the $variantName build."
        violationRules {
            rule {
                limit {
                    minimum = 0
                }
            }
            rule {
                element = 'BUNDLE'
                limit {
                    counter = 'LINE'
                    value = 'COVEREDRATIO'
                    minimum = 0.30
                }
            }
        }
        getClassDirectories().setFrom(aggregateTask.getClassDirectories())
        getSourceDirectories().setFrom(aggregateTask.getSourceDirectories())
        getAdditionalSourceDirs().setFrom(aggregateTask.getAdditionalSourceDirs())
        getExecutionData().setFrom(aggregateTask.getExecutionData())
    }

    // Add JavaLibrary report data
    if (variantName != 'javaLibrary') {
        def aggregateJavaTask = rootProject.tasks.findByName('aggregateJavaLibraryTestCoverage')
        if (aggregateJavaTask != null) {
            setupWithAggregateCoverage(variantName, aggregateJavaTask)
        } else {
            rootProject.tasks.whenTaskAdded { addedTask ->
                if (addedTask.name == 'aggregateJavaLibraryTestCoverage') {
                    setupWithAggregateCoverage(variantName, addedTask)
                }
            }
        }
    }

    return aggregateTask
}

def createVariantCoverage(subproject, variant) {
    def variantName = variant.name
    def javaClasses = subproject.fileTree(dir: variant.javaCompileProvider.get().destinationDir, excludes: project.excludes)
    def kotlinClasses = subproject.fileTree(dir: "${subproject.buildDir}/tmp/kotlin-classes/${variantName}", excludes: project.excludes)
    def moduleClassDirectories = subproject.files([javaClasses, kotlinClasses])
    def moduleSourceDirectories = subproject.files(variant.sourceSets.java.srcDirs.collect { it.path }.flatten())
    def moduleExecutionData = files([
            fileTree(dir: "${subproject.buildDir}/outputs/unit_test_code_coverage/${variantName}UnitTest/", includes: ["**/*.exec"]),
            fileTree(dir: "${subproject.buildDir}/outputs/code_coverage/${variantName}AndroidTest/connected/", includes: ["**/*.ec"])
    ])
    def testTaskName = "test${variantName.capitalize()}UnitTest"
    def androidTestTaskName = "create${variantName.capitalize()}CoverageReport"


    // Add unit test coverage tasks for module
    JacocoReport reportTask = subproject.tasks.create(name: "${testTaskName}Coverage", type: JacocoReport) {
        group = "Reporting"
        description = "Generate Jacoco coverage reports for the ${variantName.capitalize()} build."

        reports {
            xml.required = true
            csv.required = false
        }

        getClassDirectories().setFrom(moduleClassDirectories)
        getSourceDirectories().setFrom(moduleSourceDirectories)
        getAdditionalSourceDirs().setFrom(moduleSourceDirectories)
        getExecutionData().setFrom(moduleExecutionData)

        if (project.useLogging) {
            println("${testTaskName}Coverage")
            println("---------------------------------------------------------------------------")
            println("getClassDirectories:")
            getClassDirectories().forEach { file ->
                println(file.absolutePath)
            }
            println("---------------------------------------------------------------------------")
            println("getSourceDirectories:")
            getSourceDirectories().forEach { file ->
                println(file.absolutePath)
            }
            println("---------------------------------------------------------------------------")
            println("getExecutionData:")
            getExecutionData().forEach { file ->
                println(file.absolutePath)
            }
            println("")
            println("")
        }

        doLast {
            println "Coverage file: ${subproject.buildDir}/reports/jacoco/${testTaskName}Coverage/html/index.html"
            def m = new File("${subproject.buildDir}/reports/jacoco/${testTaskName}Coverage/html/index.html")
                    .text =~ /Total[^%]*>(\d?\d?\d?%)/
            if (m) {
                println "Test coverage: ${m[0][1]}"
            }
        }
    }

    def testTask = subproject.tasks.findByName(testTaskName)
    def androidCoverageTask = subproject.tasks.findByName(androidTestTaskName)
    if (testTask != null) {
        reportTask.dependsOn(testTask)
    }

    if (androidCoverageTask != null) {
        reportTask.dependsOn(androidCoverageTask)
    }

    // Add unit test coverage verification tasks
    subproject.tasks.create(name: "${testTaskName}CoverageVerification", type: JacocoCoverageVerification, dependsOn: reportTask) {
        group = "Reporting"
        description = "Verifies Jacoco coverage for the ${variantName.capitalize()} build."
        violationRules {
            rule {
                limit {
                    minimum = 0
                }
            }
            rule {
                element = 'BUNDLE'
                limit {
                    counter = 'LINE'
                    value = 'COVEREDRATIO'
                    minimum = 0.30
                }
            }
        }
        getClassDirectories().setFrom(reportTask.classDirectories)
        getSourceDirectories().setFrom(reportTask.sourceDirectories)
        getExecutionData().setFrom(reportTask.executionData)
    }
    setupWithAggregateCoverage(variant.name, reportTask)
}

def createJavaLibraryCoverage(subproject, JacocoReport reportTask) {
    reportTask.reports {
        html.enabled = true
        xml.enabled = true
    }
    if (!fileTree(dir: "${subproject.projectDir}/src/test", includes: ["**/*.kt", "**/*.java"]).isEmpty()) {
        reportTask.dependsOn(subproject.tasks.findByName('test'))
        setupWithAggregateCoverage("javaLibrary", reportTask)
    }
}